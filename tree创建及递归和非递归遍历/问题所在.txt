根据你的疑问，能看出你还没有彻底弄清楚函数参数为普通变量 or 指针变量所带来的区别，以及应该在哪些场合选用恰当的类型。

首先需要再次说明，函数参数传递是单向传递，当主调函数发出调用指令时，编译器会将实参的值的拷贝传递给形参，然后在函数体内进行后续加工和操作。这么一来，如果形参在函数体内发生了改变，且主调函数需要得到这个改变，也就是让实参也同步发生改变，那么被调函数的参数列表里对应的形参就需要设计成为变量的指针类型。因为一旦形参为指针类型，编译器会将实参的地址传递给形参，从而让形参指向同一内存地址空间，那么自然在被调函数体内发生的任何内存加工，都等效于对实参进行的操作了。

那么我们来看你的代码，main函数中，

	binaryTree tree;			//语句1
    	CreatBiTree(&tree,fp);		//语句2
   	 printf("%c",tree.data);		//语句3

首先你的binaryTree类型为结构体变量，编译器执行语句1后，会为变量tree分配结构体大小的内存空间，（注意，这个地址是编译器自动分配的）该空间包含了一个char变量，两个struct node *指针变量，总共3个变量所占空间之和。然后，编译器执行语句2后，虽然你是将语句1编译器分配的那个空间的地址传递了过去，但是CreatBiTree函数体内为二叉树分配的各个结点全部是通过手动调用malloc函数分配而来，包括二叉树根结点！既然整个CreatBiTree函数都没有触碰到语句1中编译器分配给变量tree的那片内存，那你怎么能够期待在语句3中通过printf语句去打印出变量tree的内容呢？自然的，后续的travelBiTree函数也是无效访问了。

所以，看出你的问题了么？

具体来说，由于CreatBiTree函数是通过递归调用，不断生成二叉树中的各个结点，每个结点都是通过指针来指向和访问的（包括根结点）。并且，访问每个结点的指针类型为strcut node *，所以，一棵二叉树需要通过一个指向根结点的指针即可依次访问到，而且也只需借助该指针。而你的源码中，首先定义了一个变量，表示根结点本身，该结点空间是由编译器分配，后续的若干结点则是通过malloc分配而来。这个思路本身就把二叉树的递归特性给破坏掉了。我们课上有讲解到，无论是一般的树还是二叉树，都是一个递归形式，所以根结点和其他结点没有任何区别，都是包含data域和两个指针域。所以，无论是根结点还是其子树结点都应该通过递归调用CreatBiTree，由函数malloc分配获得。所以，我们在定义二叉树的时候，应该定义为指向结构体的指针类型。也即：

typedef struct node{
    char data;
    struct node * lchild;
    struct node * rchild;
}*binaryTree;

然后在main中定义 binaryTree tree; 相应的，两个函数申明也需要修改为：

//创建二叉树
int  CreatBiTree(binaryTree *btree,FILE *fp);

//遍历二叉树
void travelBiTree(binaryTree tree);

其中，函数CreatBiTree第一个参数类型应该定义为binaryTree *，因为tree所指空间将通过执行CreatBiTree函数得到，其指向已经发生了改变，所以参数类型需要修改为指向指针的指针，也即二级指针。而函数travelBiTree只是访问二叉树tree，所以参数类型保持原有类型不变。

具体的代码调整见我附上的修改后的源码。

另外，我想对之前邮件关于你栈类型定义的修改建议，结合本次二叉树问题，再给你强调一下：

上次栈的实验中，你的OPND和OPTR的结构体类型定义中，包含了一个base、top以及stacksize三个成员变量。那么你通过OPND或者OPTR类型定义变量opnd或者optr，编译器会自动为其分配变量空间。但这个要注意，这个空间对应的是变量opnd或者optr，而该栈变量入栈出栈对应的空间是指针变量base所指空间，该空间是通过调用InitStack函数，借助malloc分配获得。所以我们只需要栈变量opnd即可，而不需要指向栈变量opnd的指针变量。而本次二叉树中，根结点和其余树的结点都是通过指针进行访问和操作，其空间是malloc分配，所以我们在定义二叉树的时候，就需要定义对应的指针变量，只是该变量一开始所指空间是待定的，一旦调用CreatBiTree函数后，其空间就可以确定下来，而我们的函数参数由于是二级指针（即指针的指针），所以在CreatBiTree函数体内的任何改变，在函数调用结束后，主调函数都能得到其改变。

所以，该如何定义和申明类型和变量，是需要根据实际情况来分析，而不能笼统地一概而论。
